<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>알고리즘 on SnowDeer&#39;s Programming Holic</title>
    <link>http://snowdeer.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/</link>
    <description>Recent content in 알고리즘 on SnowDeer&#39;s Programming Holic</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://snowdeer.github.io/categories/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Binary Indexed Tree</title>
      <link>http://snowdeer.github.io/post/2016-03-30-binary-indexed-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://snowdeer.github.io/post/2016-03-30-binary-indexed-tree/</guid>
      <description>

&lt;p class=&#34;message&#34;&gt;
이진수 값을 인덱스로 활용해서 구간별 최소/최대/합 등을 쉽게 구할 수 있게 해주는
트리 형태의 데이터 구조입니다.
&lt;/p&gt;

&lt;h3 id=&#34;segment-tree-vs-binary-indexed-tree&#34;&gt;Segment Tree vs Binary Indexed Tree&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://snowdeer.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/2016/03/28/segment-tree.html&#34;&gt;Segment Tree&lt;/a&gt;로부터
좀 더 발전된 트리이며, 개념도 비슷합니다. Segment Tree 보다 더 적은 데이터 공간을
필요로 하며 코드 구현이 더 쉽습니다.&lt;/p&gt;

&lt;p&gt;다만 처음 이해하는 과정이 조금 복잡하여 Segment Tree의 개념부터 이해를 하고
도전을 하는 것이 좋을 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-01.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;어디서 많이 본 트리입니다 바로 &lt;a href=&#34;http://snowdeer.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/2016/03/28/segment-tree.html&#34;&gt;Segment Tree&lt;/a&gt;입니다.&lt;/p&gt;

&lt;p&gt;여기서 잘 생각해보면 부모 노드는 어차피 자식 노드들의 정보로 이루어져 있기 때문에
중복된 데이터들이 존재하는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 아래 예시와 같은 데이터가 있다면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;왼쪽 자식 노드의 값 100, 오른쪽 자식 노드의 값 200&lt;/li&gt;
&lt;li&gt;부모 노드는 자식 노드들의 값의 합이라고 하면 100 + 200 = 300&lt;/li&gt;
&lt;li&gt;오른쪽 자식 노드가 없더라도 부모 노드의 값과 왼쪽 자식 노드의 값만 알면, 오른쪽 자식 노드의 값을 유추할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉, Segment Tree에서&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-02.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;회색 부분의 공간은 불필요한 공간이 되며,&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-03.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;와 같은 형태로 데이터 구조를 가져갈 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;binary-indexed-tree-구조&#34;&gt;Binary Indexed Tree 구조&lt;/h3&gt;

&lt;p&gt;실제로 값을 넣어보도록 합시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-04.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;실제 데이터는 대략 이런 식으로 저장이 된다고 가정 하면,
Binary Indexed Tree는 다음과 같은 형태로 구성이 됩니다.
(해당 구간의 데이터의 합을 구하는 Binary Indexed Tree라고 가정했습니다.)&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-05.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;다시 1차원 배열로 표현해보면 Binary Tree는&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-06.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;binary-indexed-tree를-이용한-구간-합-구하기&#34;&gt;Binary Indexed Tree를 이용한 구간 합 구하기&lt;/h3&gt;

&lt;p&gt;Binary Indexed Tree를 이용하면 구간 합을 빠르게 구할 수 있습니다.
예를 들어 1번째 노드부터 7번째 노드까지의 구간 합은&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-07.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;과 같이 3개의 노드만 탐색하면 구할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;binary-indexed-tree의-노드-인덱스&#34;&gt;Binary Indexed Tree의 노드 인덱스&lt;/h3&gt;

&lt;p&gt;Binary Indexed Tree의 각 노드별 인덱스를 구할 수 있으면, Binary Indexed Tree를 사용할 수 있는 준비는 거의 끝났다고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;각 노드마다 인덱스를 붙여보도록 합시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-08.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이름 그대로 이진(Binary)법을 각 인덱스에 적용하면 다음과 같은 값이 되는데, 노드간 값을 잘 보면 규칙성이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-09.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어서, 노드 3번의 인덱스는 0011 입니다. 노드 3번의 부모는 4번 노드로 인덱스는 0100 입니다. 4번 노드의 부모는 8번 노드로 인덱스는 1000 입니다.&lt;/p&gt;

&lt;p&gt;예를 하나만 더 들어보겠습니다. 노드 5번의 인덱스는 0101 입니다. 노드 5의 부모는 6번 노드이고 인덱스는 0110 입니다. 노드 6의 부모는 노드 8이며 인덱스는 1000 입니다.&lt;/p&gt;

&lt;p&gt;부모 노드와 자식 노드간의 규칙은 다음과 같습니다.&lt;/p&gt;

&lt;p class=&#34;message&#34;&gt;
부모 노드의 인덱스는 자식 노드의 인덱스의 가장 마지막 &#39;1&#39; 값에 1을 더한 값
&lt;/p&gt;

&lt;p&gt;현재 이진 인덱스 값에서 가장 마지막에 위치한 &amp;lsquo;1&amp;rsquo;의 위치는 &amp;lsquo;index &amp;amp; (-index)&amp;lsquo;의
bit 연산을 통해서 얻을 수 있습니다. 즉, 현재 인덱스 값에
위의 &amp;lsquo;index &amp;amp; (-index)&amp;rsquo; 값을 더하면 부모 노드의 인덱스 값이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;binary-indexed-tree-값-업데이트-및-구간-합-구하기&#34;&gt;Binary Indexed Tree 값 업데이트 및 구간 합 구하기&lt;/h3&gt;

&lt;p&gt;Binary Indexed Tree에 값을 업데이트하거나 구간 합을 구하는 방법은
&lt;a href=&#34;http://snowdeer.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/2016/03/28/segment-tree.html&#34;&gt;Segment Tree&lt;/a&gt;와 비슷합니다.&lt;/p&gt;

&lt;p&gt;자식 노드의 값이 변경이 되면 부모 노드의 값들을 전부 업데이트해줘야 하죠.&lt;/p&gt;

&lt;p&gt;그리고 자식과 부모 노드간의 관계는 앞에서 알아본 자식 노드 인덱스 가장 마지막 &amp;lsquo;1&amp;rsquo; 값에
1을 더하는 방법으로 구합니다.&lt;/p&gt;

&lt;p&gt;값을 업데이트 할 때는 자식 노드부터 시작해서 가장 마지막 1 bit에 1을 더하면서 부모
노드를 찾아가서 값을 계속 생신해주면 됩니다.&lt;/p&gt;

&lt;p&gt;거꾸로 1부터 N 노드까지의 합을 구할 때는 N 노드부터 시작해서 가장 마지막 1 bit에 1을
빼면서 0이 될때까지 각 노드들의 합을 구하면 됩니다.&lt;/p&gt;

&lt;p&gt;직접 코드로 확인해보도록 합시다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;코드-정의&#34;&gt;코드 (정의)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static const int MAX_TREE_SIZE = 100000;
static const int INFINITE = 9999999;
int data[] = { 0, 2, 4, 1, 7, 3, 6, 2, 5, };
int N = 8;
int bit[MAX_TREE_SIZE];

void initialize() {
    int size = 2 * N - 1;
    for (int i = 1; i &amp;lt;= size; i++) {
        bit[i] = 0;
    }
}

void debug() {
    for (int i = 1; i &amp;lt;= N; i++) {
        printf(&amp;quot;%d &amp;quot;, bit[i]);
    }

    printf(&amp;quot;\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;코드-데이터-갱신&#34;&gt;코드 (데이터 갱신)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void update(int index, int value) {
    while (index &amp;lt;= N) {
        bit[index] = bit[index] + value;
        index = index + (index &amp;amp; (-index));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;코드-1부터-n까지-구간-합&#34;&gt;코드 (1부터 N까지 구간 합)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int sum(int index) {
    int sum = 0;
    while (index &amp;gt; 0) {
        sum = sum + bit[index];
        index = index - (index &amp;amp; (-index));
    }

    return sum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;코드-전체-소스-코드&#34;&gt;코드 (전체 소스 코드)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

static const int MAX_TREE_SIZE = 100000;
static const int INFINITE = 9999999;
int data[] = { 0, 2, 4, 1, 7, 3, 6, 2, 5, };
int N = 8;
int bit[MAX_TREE_SIZE];

void initialize() {
    int size = 2 * N - 1;
    for (int i = 1; i &amp;lt;= size; i++) {
        bit[i] = 0;
    }
}

void debug() {
    for (int i = 1; i &amp;lt;= N; i++) {
        printf(&amp;quot;%d &amp;quot;, bit[i]);
    }

    printf(&amp;quot;\n&amp;quot;);
}

void update(int index, int value) {
    while (index &amp;lt;= N) {
        bit[index] = bit[index] + value;
        index = index + (index &amp;amp; (-index));
    }
}

int sum(int index) {
    int sum = 0;
    while (index &amp;gt; 0) {
        sum = sum + bit[index];
        index = index - (index &amp;amp; (-index));
    }

    return sum;
}


int main(int argc, char** argv) {
    initialize();

    for (int i = 1; i &amp;lt;= N; i++) {
        update(i, data[i]);
    }

    // Binary Indexed Tree 출력
    debug();

    printf(&amp;quot;Sum (1 ~ %d) : %d\n&amp;quot;, 3, sum(3));
    printf(&amp;quot;Sum (1 ~ %d) : %d\n&amp;quot;, 5, sum(5));
    printf(&amp;quot;Sum (1 ~ %d) : %d\n&amp;quot;, 7, sum(7));

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
