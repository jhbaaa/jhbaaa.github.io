---
layout: post
title: Counting Sort
category: 알고리즘
tag: algorithm, counting, sort
---

~~~
O(N) 성능을 가지는 정렬 알고리즘입니다.
~~~

O(N) 성능이라고 하면, 그냥 데이터들을 한 번 읽고 지나가면 
정렬이 되는... 그런 속도입니다.

일반적으로 많이 쓰는 정렬 알고리즘들인 Quick Sort나 Merge Sort가
O(N log N)임을 생각하면 상당히 놀라운 성능입니다.

그리고 성능도 좋은데, 구현도 엄청 쉽습니다.
이름 그대로 그냥 카운팅만 하면 되거든요.

<br>

## 원리

카운팅 정렬의 원리는 다음과 같습니다.

카운팅 하고자 하는 숫자 값중 가장 큰 값만큼의 배열을 하나 만듭니다.
예를 들어서 정렬하고자 하는 값이 
{ 5, 14, 2, 7, 11, 3, 6, 10, 9, 18 } 라고 하면
이 중에서 가장 큰 값이 18이니깐 18만큼의 배열을 하나 만듭니다.
넉넉하게 크기 20짜리 배열을 하나 만드는게 좋겠네요.

저는 아래 코드에서는 result 라는 배열로 만들었습니다.

그리고 데이터를 처음부터 읽으면서 그 값을 인덱스로 하는 칸에 +1 해줍니다. 
예를 들어 데이터가 숫자 5인 경우는 result[5]를 +1 해주면 됩니다.

이렇게 모든 데이터를 읽어 들인 후, 그 다음에는 result 배열을 
처음부터 읽으면서 그 값이 0보다 큰 경우에만 출력을 해주면 끝납니다.

<br>

## 코드


<pre class="prettyprint">
const int MAX = 10;
int data[MAX] = { 5, 14, 2, 7, 11, 3, 6, 10, 9, 18, };
int result[20];

int main(int argc, char** argv) {
    for (int i = 0; i < MAX; i++) {
        int index = data[i];
        result[index]++;
    }

    for (int i = 0; i <= 20; i++) {
        if (result[i] > 0) {
            printf("%d ", i);
        }
    }
    printf("\n");

    return 0;
}
</pre>

<br>

## 요약

성능이 O(N) 이라고 하지만 Quick Sort나 Merge Sort보다 성능이
항상 더 좋은 것은 아닙니다. 
표현은 O(N)이지만, 사실은 O(배열의 최대값) 이거든요.

예를 들어 N = 2이고 데이터는 { 1, 999999 } 라고 하면
카운팅 정렬을 쓰면 오히려 시간이 더 오래걸리는 경우가 발생합니다.

하지만, 카운팅 정렬을 사용하면 효율적인 경우는 자주 있습니다.
다음과 같이 숫자 범위가 작은데 데이터 크기가 큰 경우는 아주 효과적이죠.
{ 1, 3, 2, 3, 2, 1, 3, 2, 1, }

구현도 쉽습니다. 그래서 정렬이 필요하면 일단은 카운팅 정렬을 먼저 고민해보고
다른 정렬을 접근하는 것도 좋을 것 같습니다.