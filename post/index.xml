<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on SnowDeer&#39;s Programming Holic</title>
    <link>http://snowdeer.github.io/post/</link>
    <description>Recent content in Posts on SnowDeer&#39;s Programming Holic</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 30 Jul 2016 16:44:45 +0900</lastBuildDate>
    <atom:link href="http://snowdeer.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>블로그를 시작하며</title>
      <link>http://snowdeer.github.io/post/hello-hugo22/</link>
      <pubDate>Sat, 30 Jul 2016 16:44:45 +0900</pubDate>
      
      <guid>http://snowdeer.github.io/post/hello-hugo22/</guid>
      <description>

&lt;p&gt;안녕하세요. 예전엔 &lt;a href=&#34;http://snowbora.tistory.com&#34;&gt;티스토리 블로그&lt;/a&gt;를 운영해왔었는데,
최근에 &lt;a href=&#34;http://github.com/&#34;&gt;GitHub&lt;/a&gt;와 연동할 수 있는
&lt;a href=&#34;https://github.com/jekyll/jekyll&#34;&gt;Jekyll&lt;/a&gt; 블로그 시스템을 알게 되어 이쪽에서 새로운 시작을 해볼까 합니다.&lt;/p&gt;

&lt;h3 id=&#34;이-블로그는&#34;&gt;이 블로그는&lt;/h3&gt;

&lt;p&gt;프로그래밍 쪽과 관련된 내용들 위주로 운영할 계획이며,
다음과 같은 내용들을 다뤄보고자 합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Design Pattern&lt;/li&gt;
&lt;li&gt;Algorithms&lt;/li&gt;
&lt;li&gt;Android Development&lt;/li&gt;
&lt;li&gt;C++11&lt;/li&gt;
&lt;li&gt;그 외 각종 소식들&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;jekyll-소개&#34;&gt;Jekyll 소개&lt;/h3&gt;

&lt;p&gt;정적인 웹페이지를 만들어주는 도구입니다. &lt;a href=&#34;https://www.ruby-lang.org/ko/&#34;&gt;Ruby&lt;/a&gt; 기반으로 되어 있으며,
날짜 기반의 웹페이지들을 마치 블로그처럼 보여줄 수 있는 기능만을 제공하고 있습니다.&lt;/p&gt;

&lt;p&gt;정적인 웹페이지로 이루어져 있기 때문에, &lt;a href=&#34;http://www.tistory.com/&#34;&gt;티스토리&lt;/a&gt;나 네이버 블로그 등과 같은
화려하고 동적인 기능들은 제공하지 않습니다. 심지어 글 작성, 댓글 작성이나 알림, 통계 등의 다양한 기능들도
지원하지 않습니다.&lt;/p&gt;

&lt;p&gt;이러한 단점이 많은데도 &lt;a href=&#34;https://github.com/jekyll/jekyll&#34;&gt;Jekyll&lt;/a&gt;을 선택한 이유는&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;동적인 요소가 없기 때문에 DB 서버 등이 필요없고, 속도도 훨씬 빠릅니다.&lt;/li&gt;
&lt;li&gt;정적인 문서 그 자체들로 이루어져 있기 떄문에 어떤 호스팅 서버에서도 동작할 수 있습니다.&lt;/li&gt;
&lt;li&gt;전 세계 많은 사람들이 사용하고 있고, 다양한 Plugin이나 확장 기능이 있어서 입맛에 맞게 바꾸기가 쉽습니다.&lt;/li&gt;
&lt;li&gt;새로운 걸 공부한다는 자체가 뭔가 재미가 있습니다. +_+&lt;/li&gt;
&lt;li&gt;그리고 가장 마음에 든 것은 아래와 같은 Syntax Highlighting 입니다. 기존 블로그들에서도 이 기능은
제공하고 있었지만, Jeykyll에서 훨씬 더 사용하기 쉽고 강력하게 지원을 해서 제가 사용하기에
딱 좋네요!!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;{% highlight c %}
int main(int argc, char** argv) {
    printf(&amp;ldquo;Hello~ Welcome to SnowDeer&amp;rsquo;s Blog.\n&amp;rdquo;);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
{% endhighlight %}&lt;/p&gt;

&lt;p&gt;다만, 웹쪽 경험이 거의 없다보니 Jekyll 에 대해 이해를 하고 익숙해져가는 과정이 쉽지는 않았네요.
조금씩 조금씩 공부해가면서 업데이트해나가다보면 언젠가는 익숙해지지 않을까 싶습니다.&lt;/p&gt;

&lt;p&gt;Thanks !!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>hello</title>
      <link>http://snowdeer.github.io/post/today/</link>
      <pubDate>Tue, 26 Jul 2016 20:30:32 +0900</pubDate>
      
      <guid>http://snowdeer.github.io/post/today/</guid>
      <description>&lt;p&gt;안녕하세여. 이건 두 번째 테스트입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hello Hugo!</title>
      <link>http://snowdeer.github.io/post/hello-hugo/</link>
      <pubDate>Sat, 30 Apr 2016 16:44:45 +0900</pubDate>
      
      <guid>http://snowdeer.github.io/post/hello-hugo/</guid>
      <description>&lt;p&gt;hello. ^^;
I am SnowDeer.
I read &lt;strong&gt;Good to Great in January 2016&lt;/strong&gt;. An awesome read sharing detailed analysis on how good companies became great.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Binary Indexed Tree</title>
      <link>http://snowdeer.github.io/post/2016-03-30-binary-indexed-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://snowdeer.github.io/post/2016-03-30-binary-indexed-tree/</guid>
      <description>

&lt;p class=&#34;message&#34;&gt;
이진수 값을 인덱스로 활용해서 구간별 최소/최대/합 등을 쉽게 구할 수 있게 해주는
트리 형태의 데이터 구조입니다.
&lt;/p&gt;

&lt;h3 id=&#34;segment-tree-vs-binary-indexed-tree&#34;&gt;Segment Tree vs Binary Indexed Tree&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://snowdeer.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/2016/03/28/segment-tree.html&#34;&gt;Segment Tree&lt;/a&gt;로부터
좀 더 발전된 트리이며, 개념도 비슷합니다. Segment Tree 보다 더 적은 데이터 공간을
필요로 하며 코드 구현이 더 쉽습니다.&lt;/p&gt;

&lt;p&gt;다만 처음 이해하는 과정이 조금 복잡하여 Segment Tree의 개념부터 이해를 하고
도전을 하는 것이 좋을 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-01.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;어디서 많이 본 트리입니다 바로 &lt;a href=&#34;http://snowdeer.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/2016/03/28/segment-tree.html&#34;&gt;Segment Tree&lt;/a&gt;입니다.&lt;/p&gt;

&lt;p&gt;여기서 잘 생각해보면 부모 노드는 어차피 자식 노드들의 정보로 이루어져 있기 때문에
중복된 데이터들이 존재하는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 아래 예시와 같은 데이터가 있다면&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;왼쪽 자식 노드의 값 100, 오른쪽 자식 노드의 값 200&lt;/li&gt;
&lt;li&gt;부모 노드는 자식 노드들의 값의 합이라고 하면 100 + 200 = 300&lt;/li&gt;
&lt;li&gt;오른쪽 자식 노드가 없더라도 부모 노드의 값과 왼쪽 자식 노드의 값만 알면, 오른쪽 자식 노드의 값을 유추할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉, Segment Tree에서&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-02.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;회색 부분의 공간은 불필요한 공간이 되며,&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-03.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;와 같은 형태로 데이터 구조를 가져갈 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;binary-indexed-tree-구조&#34;&gt;Binary Indexed Tree 구조&lt;/h3&gt;

&lt;p&gt;실제로 값을 넣어보도록 합시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-04.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;실제 데이터는 대략 이런 식으로 저장이 된다고 가정 하면,
Binary Indexed Tree는 다음과 같은 형태로 구성이 됩니다.
(해당 구간의 데이터의 합을 구하는 Binary Indexed Tree라고 가정했습니다.)&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-05.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;다시 1차원 배열로 표현해보면 Binary Tree는&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-06.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;binary-indexed-tree를-이용한-구간-합-구하기&#34;&gt;Binary Indexed Tree를 이용한 구간 합 구하기&lt;/h3&gt;

&lt;p&gt;Binary Indexed Tree를 이용하면 구간 합을 빠르게 구할 수 있습니다.
예를 들어 1번째 노드부터 7번째 노드까지의 구간 합은&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-07.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;과 같이 3개의 노드만 탐색하면 구할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;binary-indexed-tree의-노드-인덱스&#34;&gt;Binary Indexed Tree의 노드 인덱스&lt;/h3&gt;

&lt;p&gt;Binary Indexed Tree의 각 노드별 인덱스를 구할 수 있으면, Binary Indexed Tree를 사용할 수 있는 준비는 거의 끝났다고 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;각 노드마다 인덱스를 붙여보도록 합시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-08.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이름 그대로 이진(Binary)법을 각 인덱스에 적용하면 다음과 같은 값이 되는데, 노드간 값을 잘 보면 규칙성이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-30-binary-indexed-tree-09.png&#34; alt=&#34;BIT&#34; /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어서, 노드 3번의 인덱스는 0011 입니다. 노드 3번의 부모는 4번 노드로 인덱스는 0100 입니다. 4번 노드의 부모는 8번 노드로 인덱스는 1000 입니다.&lt;/p&gt;

&lt;p&gt;예를 하나만 더 들어보겠습니다. 노드 5번의 인덱스는 0101 입니다. 노드 5의 부모는 6번 노드이고 인덱스는 0110 입니다. 노드 6의 부모는 노드 8이며 인덱스는 1000 입니다.&lt;/p&gt;

&lt;p&gt;부모 노드와 자식 노드간의 규칙은 다음과 같습니다.&lt;/p&gt;

&lt;p class=&#34;message&#34;&gt;
부모 노드의 인덱스는 자식 노드의 인덱스의 가장 마지막 &#39;1&#39; 값에 1을 더한 값
&lt;/p&gt;

&lt;p&gt;현재 이진 인덱스 값에서 가장 마지막에 위치한 &amp;lsquo;1&amp;rsquo;의 위치는 &amp;lsquo;index &amp;amp; (-index)&amp;lsquo;의
bit 연산을 통해서 얻을 수 있습니다. 즉, 현재 인덱스 값에
위의 &amp;lsquo;index &amp;amp; (-index)&amp;rsquo; 값을 더하면 부모 노드의 인덱스 값이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;binary-indexed-tree-값-업데이트-및-구간-합-구하기&#34;&gt;Binary Indexed Tree 값 업데이트 및 구간 합 구하기&lt;/h3&gt;

&lt;p&gt;Binary Indexed Tree에 값을 업데이트하거나 구간 합을 구하는 방법은
&lt;a href=&#34;http://snowdeer.github.io/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/2016/03/28/segment-tree.html&#34;&gt;Segment Tree&lt;/a&gt;와 비슷합니다.&lt;/p&gt;

&lt;p&gt;자식 노드의 값이 변경이 되면 부모 노드의 값들을 전부 업데이트해줘야 하죠.&lt;/p&gt;

&lt;p&gt;그리고 자식과 부모 노드간의 관계는 앞에서 알아본 자식 노드 인덱스 가장 마지막 &amp;lsquo;1&amp;rsquo; 값에
1을 더하는 방법으로 구합니다.&lt;/p&gt;

&lt;p&gt;값을 업데이트 할 때는 자식 노드부터 시작해서 가장 마지막 1 bit에 1을 더하면서 부모
노드를 찾아가서 값을 계속 생신해주면 됩니다.&lt;/p&gt;

&lt;p&gt;거꾸로 1부터 N 노드까지의 합을 구할 때는 N 노드부터 시작해서 가장 마지막 1 bit에 1을
빼면서 0이 될때까지 각 노드들의 합을 구하면 됩니다.&lt;/p&gt;

&lt;p&gt;직접 코드로 확인해보도록 합시다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;코드-정의&#34;&gt;코드 (정의)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static const int MAX_TREE_SIZE = 100000;
static const int INFINITE = 9999999;
int data[] = { 0, 2, 4, 1, 7, 3, 6, 2, 5, };
int N = 8;
int bit[MAX_TREE_SIZE];

void initialize() {
    int size = 2 * N - 1;
    for (int i = 1; i &amp;lt;= size; i++) {
        bit[i] = 0;
    }
}

void debug() {
    for (int i = 1; i &amp;lt;= N; i++) {
        printf(&amp;quot;%d &amp;quot;, bit[i]);
    }

    printf(&amp;quot;\n&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;코드-데이터-갱신&#34;&gt;코드 (데이터 갱신)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void update(int index, int value) {
    while (index &amp;lt;= N) {
        bit[index] = bit[index] + value;
        index = index + (index &amp;amp; (-index));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;코드-1부터-n까지-구간-합&#34;&gt;코드 (1부터 N까지 구간 합)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int sum(int index) {
    int sum = 0;
    while (index &amp;gt; 0) {
        sum = sum + bit[index];
        index = index - (index &amp;amp; (-index));
    }

    return sum;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;코드-전체-소스-코드&#34;&gt;코드 (전체 소스 코드)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

static const int MAX_TREE_SIZE = 100000;
static const int INFINITE = 9999999;
int data[] = { 0, 2, 4, 1, 7, 3, 6, 2, 5, };
int N = 8;
int bit[MAX_TREE_SIZE];

void initialize() {
    int size = 2 * N - 1;
    for (int i = 1; i &amp;lt;= size; i++) {
        bit[i] = 0;
    }
}

void debug() {
    for (int i = 1; i &amp;lt;= N; i++) {
        printf(&amp;quot;%d &amp;quot;, bit[i]);
    }

    printf(&amp;quot;\n&amp;quot;);
}

void update(int index, int value) {
    while (index &amp;lt;= N) {
        bit[index] = bit[index] + value;
        index = index + (index &amp;amp; (-index));
    }
}

int sum(int index) {
    int sum = 0;
    while (index &amp;gt; 0) {
        sum = sum + bit[index];
        index = index - (index &amp;amp; (-index));
    }

    return sum;
}


int main(int argc, char** argv) {
    initialize();

    for (int i = 1; i &amp;lt;= N; i++) {
        update(i, data[i]);
    }

    // Binary Indexed Tree 출력
    debug();

    printf(&amp;quot;Sum (1 ~ %d) : %d\n&amp;quot;, 3, sum(3));
    printf(&amp;quot;Sum (1 ~ %d) : %d\n&amp;quot;, 5, sum(5));
    printf(&amp;quot;Sum (1 ~ %d) : %d\n&amp;quot;, 7, sum(7));

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Counting Sort</title>
      <link>http://snowdeer.github.io/post/2016-03-18-counting-sorting-algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://snowdeer.github.io/post/2016-03-18-counting-sorting-algorithm/</guid>
      <description>

&lt;p class=&#34;message&#34;&gt;
O(N) 성능을 가지는 정렬 알고리즘입니다.
&lt;/p&gt;

&lt;p&gt;O(N) 성능이라고 하면, 그냥 데이터들을 한 번 읽고 지나가면
정렬이 되는&amp;hellip; 그런 속도입니다.&lt;/p&gt;

&lt;p&gt;일반적으로 많이 쓰는 정렬 알고리즘들인 Quick Sort나 Merge Sort가`
O(N log N)임을 생각하면 상당히 놀라운 성능입니다.&lt;/p&gt;

&lt;p&gt;그리고 성능도 좋은데, 구현도 엄청 쉽습니다.
이름 그대로 그냥 카운팅만 하면 되거든요.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;원리&#34;&gt;원리&lt;/h3&gt;

&lt;p&gt;카운팅 정렬의 원리는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;카운팅 하고자 하는 숫자 값중 가장 큰 값만큼의 배열을 하나 만듭니다.
예를 들어서 정렬하고자 하는 값이
{ 5, 14, 2, 7, 11, 3, 6, 10, 9, 18 } 라고 하면
이 중에서 가장 큰 값이 18이니깐 18만큼의 배열을 하나 만듭니다.
넉넉하게 크기 20짜리 배열을 하나 만드는게 좋겠네요.&lt;/p&gt;

&lt;p&gt;저는 아래 코드에서는 result 라는 배열로 만들었습니다.&lt;/p&gt;

&lt;p&gt;그리고 데이터를 처음부터 읽으면서 그 값을 인덱스로 하는 칸에
+1을 해줍니다. 예를 들어 데이터가 숫자 5인 경우는 result[5]를 +1
해주면 됩니다.&lt;/p&gt;

&lt;p&gt;이렇게 모든 데이터를 읽어 들인 후, 그 다음에는 result 배열을
처음부터 읽으면서 그 값이 0보다 큰 경우에만 출력을 해주면 끝납니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;const int MAX = 10;
int data[MAX] = { 5, 14, 2, 7, 11, 3, 6, 10, 9, 18, };
int result[20];

int main(int argc, char** argv) {
    for (int i = 0; i &amp;lt; MAX; i++) {
        int index = data[i];
        result[index]++;
    }

    for (int i = 0; i &amp;lt;= 20; i++) {
        if (result[i] &amp;gt; 0) {
            printf(&amp;quot;%d &amp;quot;, i);
        }
    }
    printf(&amp;quot;\n&amp;quot;);

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;요약&#34;&gt;요약&lt;/h3&gt;

&lt;p&gt;성능이 O(N) 이라고 하지만 Quick Sort나 Merge Sort보다 성능이
항상 더 좋은 것은 아닙니다.
표현은 O(N)이지만, 사실은 O(배열의 최대값) 이거든요.&lt;/p&gt;

&lt;p&gt;예를 들어 N = 2이고 데이터는 { 1, 999999 } 라고 하면
카운팅 정렬을 쓰면 오히려 시간이 더 오래걸리는 경우가 발생합니다.&lt;/p&gt;

&lt;p&gt;하지만, 카운팅 정렬을 사용하면 효율적인 경우는 자주 있습니다.
다음과 같이 숫자 범위가 작은데 데이터 크기가 큰 경우는 아주 효과적이죠.
{ 1, 3, 2, 3, 2, 1, 3, 2, 1, }&lt;/p&gt;

&lt;p&gt;구현도 쉽구요. 그래서 정렬이 필요하면 일단은 카운팅 정렬을 한 번
고려해본다음 다른 정렬을 생각하는 식으로 접근해도 좋을 것 같습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Heap</title>
      <link>http://snowdeer.github.io/post/2016-03-19-heap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://snowdeer.github.io/post/2016-03-19-heap/</guid>
      <description>

&lt;p class=&#34;message&#34;&gt;
부모 노드의 값은 자식 노드의 값보다 항상 크다(또는 작다)라는 규칙을 갖고 있는 
트리 형태의 자료 구조를 Heap 이라고 합니다.
&lt;/p&gt;

&lt;p&gt;크게 Max Heap과 Min Heap으로 나누어집니다. Max Heap 은 부모 노드의 값이 항상
자식 노드의 값보다 커야 하며, Min Heap은 그 반대입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-19-heap-01.png&#34; alt=&#34;Heap&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Heap의 성격상 최상위 노드인 root 노드에는 해당 자료 집합들 중에서 가장 큰(작은) 값이
저장됩니다. 즉, Heap에서 데이터를 하나씩 꺼내게 되면 정렬과 같은 효과를 가지는데,
이러한 정렬을 Heap Sort라고 합니다. 성능은 O(N log N) 입니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;특징&#34;&gt;특징&lt;/h3&gt;

&lt;p&gt;Heap은 이진 트리(Binary Tree) 형태로 이루어져 있습니다. 그리고 이진 트리 중에서도
완전 이진 트리(Complete Binary Tree) 입니다.&lt;/p&gt;

&lt;p&gt;완전 이진 트리라는 특징(앞에서부터 차례대로 채워지는 규칙) 때문에 Heap을 구현할 때는
보통 트리보다는 배열을 이용해서 구현을 합니다. 위 그림의 트리를 배열로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-19-heap-02.png&#34; alt=&#34;Heap_Array&#34; /&gt;&lt;/p&gt;

&lt;p&gt;배열 칸에는 값이 들어가며, 위에는 배열 칸의 인덱스입니다. 배열은 0부터 시작해도 되고,
1부터 시작해도 됩니다.&lt;/p&gt;

&lt;p&gt;저는 그냥 1부터 시작하는게 습관이 되서 1부터 주로 채워나갑니다.&lt;/p&gt;

&lt;p&gt;배열 칸의 인덱스와 트리안의 노드들과의 관계는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-19-heap-03.png&#34; alt=&#34;Heap_Array_and_Tree&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이제 부모 노드와 자식 노드간의 관계를 알 수가 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-19-heap-04.png&#34; alt=&#34;Parent_and_Child&#34; /&gt;&lt;/p&gt;

&lt;p&gt;바로 위 그림과 같은 관계를 가집니다.
자식 노드의 인덱스를 2로 나누면 부모 노드의 인덱스가 되고, 반대로 부모 노드에서
자식 노드는 2를 곱한 값과 2를 곱한 값에 1을 더한 값을 인덱스로 가지게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;heap을-사용하는-이유&#34;&gt;Heap을 사용하는 이유&lt;/h3&gt;

&lt;p&gt;단순히 최소, 최대 값만을 구할 거면 그냥 모든 숫자를 한 번씩만 읽으면 O(N)으로 끝납니다. 조금 더 투자해서 정렬을 한다고 치면 보통 O(N log N) 정도면 충분합니다.
그런데도 왜 Heap이라는 자료 구조를 사용하는 걸까요?&lt;/p&gt;

&lt;p&gt;바로 데이터가 중간에 삽입되거나 삭제되었을 때, 위의 경우는 정렬을 새로 하거나
모든 숫자를 다시 읽는 과정이 필요한데, Heap은 그런 과정을 최소한으로 줄여주기 때문에
데이터 변경이 빈번한 경우는 Heap을 사용하는 것이 훨씬 더 효율적이 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;코드-정의&#34;&gt;코드 (정의)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static const int MAX_HEAP_SIZE = 1000;
class Heap {
public:
    Heap() {
        size = 0;
    }

    void push(int value);
    int pop();

private:
    int data[MAX_HEAP_SIZE];
    int size;

    void swap(int pos1, int pos2) {
        int temp = data[pos1];
        data[pos1] = data[pos2];
        data[pos2] = temp;
    }
};

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Heap의 함수는 크게 2개 정도가 있습니다. 데이터의 삽입과 삭제죠.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;코드-구현&#34;&gt;코드 (구현)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void Heap::push(int value) {
    size++;
    data[size] = value;

    int pos = size;
    while (true) {
        if (pos == 1) break;

        int parent_idx = pos / 2;
        int parent_value = data[parent_idx];

        if (parent_value &amp;lt;= data[pos]) {
            break;
        }
        
        swap(parent_idx, pos);
        pos = parent_idx;
    }
}

int Heap::pop() {
    if (size &amp;lt;= 0) return -1;
    int ret = data[1];
    data[1] = data[size];
    size--;

    int pos = 1;
    while (true) {
        int left_child_idx = pos * 2;
        int right_child_idx = pos * 2 + 1;

        if (left_child_idx &amp;gt; size) break;
        
        // child node 가 1개인 경우와 2개인 경우를 나누어 처리
        if (right_child_idx &amp;gt; size) { 
            int left_child_value = data[left_child_idx];
            if (left_child_value &amp;gt;= data[pos]) {
                break;
            }
            swap(left_child_idx, pos);
            pos = left_child_idx;
        }
        else {
            int left_child_value = data[left_child_idx];
            int right_child_value = data[right_child_idx];

            if ((left_child_value &amp;gt;= data[pos]) &amp;amp;&amp;amp; (right_child_value &amp;gt;= data[pos])) {
                break;
            }

            if (left_child_value &amp;lt;= right_child_value) {
                swap(left_child_idx, pos);
                pos = left_child_idx;
            }
            else {
                swap(right_child_idx, pos);
                pos = right_child_idx;
            }
        }
    }

    return ret;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;요약&#34;&gt;요약&lt;/h3&gt;

&lt;p&gt;Heap을 쓰는 경우가 그리 많지는 않은데, 그래도 사용하게 되는 경우가 어쩌다가 한 번씩 생깁니다. 대표적으로 우선 순위 큐(Priority Queue)가 있습니다. 우선 순위 큐를 쓰는
알고리즘 문제 중에서도 대표적인게 최단 경로 찾기(ex. Dijkstra) 알고리즘 등이 있구요.&lt;/p&gt;

&lt;p&gt;구현해야 할 내용은 꽤 많은데, 로직 자체가 어렵지는 않으니 공부해놓으면 손해는 보지 않을 것 같네요. ㅋ&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Merge Sort</title>
      <link>http://snowdeer.github.io/post/2016-03-09-merge-sorting-algorithm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://snowdeer.github.io/post/2016-03-09-merge-sorting-algorithm/</guid>
      <description>

&lt;p class=&#34;message&#34;&gt;
O(N log N) 성능을 가지는 정렬 알고리즘입니다.
&lt;/p&gt;

&lt;p&gt;알고리즘 공부를 하다보면 간단한 정렬 알고리즘 하나 정도는 알아 놓는 편이 좋은데,
정렬 알고리즘들은 정말 다양합니다. 성능도 각양각색이구요.&lt;/p&gt;

&lt;p&gt;보통 Quick Sort 또는 Merge Sort가 가장 대표적인데,
둘 다 분할 정복 기반 알고리즘이며 성능도 O(N log N)으로 비슷합니다.&lt;/p&gt;

&lt;p&gt;어떤 알고리즘을 쓰나 상관은 없는데 최악의 경우에는 Quick Sort의 경우 O(N^2)으로
성능이 저하되지만, Merge Sort는 최악의 경우에도 O(N log N)을 유지해주는
고마운(?) 정렬 알고리즘입니다. 평균적으로는 Quick Sort가 더 빠르다는 말도 있는데,
사실 평소에는 어떤 것을 쓰더라도 거기서 거기인 것 같습니다.&lt;/p&gt;

&lt;p&gt;저는 Merge Sort 알고리즘이 개념적으로 이해하기도 쉽고 구현하기도 쉬워서
애용하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;자, 그럼 일단 개념부터 한 번 보면,&lt;/p&gt;

&lt;p class=&#34;message&#34;&gt;
분할 정복 알고리즘 기반입니다. 분할을 해볼까요?
&lt;/p&gt;

&lt;h3 id=&#34;분할&#34;&gt;분할&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-09-merge-sorting-algorithm-01.png&#34; alt=&#34;Divide&#34; /&gt;&lt;/p&gt;

&lt;p&gt;그냥 무조건 1/2씩 나누기만 하면 됩니다.
&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;정합&#34;&gt;정합&lt;/h3&gt;

&lt;p&gt;이렇게 나누어진 값들은 합치면서 정렬을 해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-09-merge-sorting-algorithm-02.png&#34; alt=&#34;Conquer&#34; /&gt;
이런 식으로 1/2로 나누었던 구간들을 다시 합해주면 됩니다.
물론 합칠 때는 정렬을 해주면서 합쳐야겠죠.&lt;/p&gt;

&lt;p&gt;대충 이런 느낌?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-09-merge-sorting-algorithm-03.png&#34; alt=&#34;Merge&#34; /&gt;&lt;/p&gt;

&lt;p&gt;여기서는 왼쪽의 1이 작으니깐 1을 빈 배열에 넣고, 빈 배열의 offset과 왼쪽 편의
offset1을 각각 증가시켜 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-09-merge-sorting-algorithm-04.png&#34; alt=&#34;Merge&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이번에는 왼쪽의 4보다는 오른 쪽의 2가 더 작으니 2를 배열에 넣어 주고
각각의 offset을 하나씩 증가시켜 줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-09-merge-sorting-algorithm-05.png&#34; alt=&#34;Merge&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이런 식이 되겠죠. 이렇게 합해가면 Merge Sort 완성입니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;코드&#34;&gt;코드&lt;/h3&gt;

&lt;p&gt;c++로 작성한 Merge Sort 코드입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int temp[MAX];
void mergeSort(int* arr, int left, int right) {
    // 종료 조건: 나눌 수 없을 때까지 나눈다.
    if (left &amp;gt;= right) return;

    // 분할
    int mid = (left + right) / 2;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);

    // 정합
    int length = right - left + 1;
    int offset = 0, offset1 = left, offset2 = mid + 1;

    while ((offset1 &amp;lt;= mid) || (offset2 &amp;lt;= right)) {
        if (offset1 &amp;gt; mid) {
            temp[offset++] = arr[offset2++];
            continue;
        }
        if (offset2 &amp;gt; right) {
            temp[offset++] = arr[offset1++];
            continue;
        }
        if (arr[offset1] &amp;lt;= arr[offset2]) {
            temp[offset++] = arr[offset1++];
            continue;
        }
        else {
            temp[offset++] = arr[offset2++];
            continue;
        }
    }

    for (int i = 0; i &amp;lt; length; i++) {
        arr[left + i] = temp[i];
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;정합 부분이 코드가 다소 길지만 그래도 이해하기가 쉬워서 저는 Merge Sort를 애용합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Microsoft Home Use Program</title>
      <link>http://snowdeer.github.io/post/2016-03-08-microsoft-office-home-use-program/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://snowdeer.github.io/post/2016-03-08-microsoft-office-home-use-program/</guid>
      <description>&lt;p class=&#34;message&#34;&gt;
  Microsoft Home Use Program 을 아시나요?
&lt;/p&gt;

&lt;p&gt;보통 컴퓨터에서 가장 많이 사용하는 프로그램 중 하나가 바로 오피스 프로그램인데요,
10,800 원에 구매해서 사용할 수 있는 방법이 있어서 포스팅을 해봅니다.&lt;/p&gt;

&lt;p&gt;바로 &lt;a href=&#34;www.microsofthup.com/&#34;&gt;Microsoft Home Use Program&lt;/a&gt; 인데요,
줄여서 HUP라고 많이 부릅니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-08-microsoft-office-home-use-program-01.png&#34; alt=&#34;Introducing HUP&#34; /&gt;&lt;/p&gt;

&lt;p&gt;간단히 직장 이메일 인증만 되면 해당 이메일로 구매할 수 있는 링크를 보내줍니다.
(물론 해당 직장이 MS와 라이센스 계약이 맺어져 있어야 하겠지만&amp;hellip;)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://products.office.com/ko-kr/office-365-home&#34;&gt;Office 365&lt;/a&gt;처럼 매달 일정 금액씩 내는게 아니라,
한 번 구매하면 평생 쓸 수 있는 패키지 구매입니다.
저도 Office 2013 때 구매해서 잘 쓰다가 이번에 2016으로 다시 구매했습니다.&lt;/p&gt;

&lt;p&gt;물론, 학생이라거나 선생님, 교직원 등이라면
 Office 365도 &lt;a href=&#34;https://products.office.com/ko-kr/student/office-in-education&#34;&gt;무료&lt;/a&gt;로 쓸 수 있으니
그냥 Office 365를 사용하는 것도 방법입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Segment Tree</title>
      <link>http://snowdeer.github.io/post/2016-03-28-segment-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://snowdeer.github.io/post/2016-03-28-segment-tree/</guid>
      <description>

&lt;p class=&#34;message&#34;&gt;
구간별 최대값, 최소값 등을 빠르게 구할 수 있게 해주는 데이터 구조입니다.
&lt;/p&gt;

&lt;h3 id=&#34;segment-tree-구조&#34;&gt;Segment Tree 구조&lt;/h3&gt;

&lt;p&gt;Segment Tree는 완전 이진 트리이며, 부모 노드는 각 자식 노드들의 범위에
대한 정보를 갖고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-28-segment-tree-01.png&#34; alt=&#34;SegmentTree&#34; /&gt;&lt;/p&gt;

&lt;p&gt;대략 이런 식의 관계를 가집니다. 실제 데이터는 맨 아래의 Leaf 노드들이 가지게 되며,
부모 노드들은 각각의 자식 노드들의 구간내의 정보를 갖게 됩니다.&lt;/p&gt;

&lt;p&gt;구간 내 최소값을 관리하는 Segment Tree를 예로 들어보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;구간별-최소값을-관리하는-segment-tree&#34;&gt;구간별 최소값을 관리하는 Segment Tree&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-28-segment-tree-02.png&#34; alt=&#34;SegmentTree&#34; /&gt;&lt;/p&gt;

&lt;p&gt;실제 데이터는 대략 이런 식으로 저장이 되고,
부모 노드에 들어갈 값들을 살펴보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-28-segment-tree-03.png&#34; alt=&#34;SegmentTree&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이런 식으로 각 부모 노드들은 해당 구간에 속하는 자식 노드들의 최소값을 저장하게 되며,&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-28-segment-tree-05.png&#34; alt=&#34;SegmentTree&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 차곡차곡 각 부모 노드들의 데이터가 채워지게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;구간별-최소값-조회&#34;&gt;구간별 최소값 조회&lt;/h3&gt;

&lt;p&gt;예를 들어 1번째 노드부터 7번째 노드까지의 최소값을 구해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-28-segment-tree-06.png&#34; alt=&#34;SegmentTree&#34; /&gt;&lt;/p&gt;

&lt;p&gt;원래는 1번째 노드부터 7번째 노드까지 차례대로 값을 확인해야 했지만,
Segment Tree에서는 위 그림과 같이 3개의 노드만 검색을 하면 최소값을
얻을 수 있습니다.&lt;/p&gt;

&lt;p&gt;데이터 사이즈가 커지면 더욱 속도 차이가 많이 나겠죠?&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;데이터-갱신&#34;&gt;데이터 갱신&lt;/h3&gt;

&lt;p&gt;데이터 갱신을 할 경우 Segment Tree는 해당 범위를 포함하고 있는 모든 부모 노드들의
값을 다시 업데이트해줘야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-28-segment-tree-07.png&#34; alt=&#34;SegmentTree&#34; /&gt;&lt;/p&gt;

&lt;p&gt;이런 식으로 4번째 노드의 값이 변경될 경우, 4번째 노드를 포함하고 있는
모든 부모 노드들의 값을 업데이트 해줘야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;코드-정의&#34;&gt;코드 (정의)&lt;/h3&gt;

&lt;p&gt;Segment Tree의 구조를 보면 실제 데이터보다
약 2배만큼의 저장 공간을 더 사용하고 있습니다.
(실제 데이터 공간과 그 범위를 관리하는 부모 노드들의 공간)&lt;/p&gt;

&lt;p&gt;따라서 아래 코드와 같이 실제 데이터보다 2배 정도의 크기를 선언해서 사용하면 되고,
초기값은 무한대로 설정했습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;static const int MAX_TREE_SIZE = 100000;
static const int INFINITE = 9999999;
int data[] = { 0, 6, 3, 7, 5, 2, 4, 8, 1, };
int N = 8;
int segment_tree[2 * MAX_TREE_SIZE];

int getMin(int a, int b) {
    if (a &amp;lt;= b) return a;
    return b;
}

void initialize() {
    int size = 2 * N - 1;
    for (int i = 1; i &amp;lt;= size; i++) {
        segment_tree[i] = INFINITE;
    }
}

void debug() {
    int size = 2 * N - 1;
    int pow = 2;
    for (int i = 1; i &amp;lt;= size; i++) {
        printf(&amp;quot;%d &amp;quot;, segment_tree[i]);
        if (i == (pow - 1)) {
            printf(&amp;quot;\n&amp;quot;);
            pow = pow * 2;
        }
    }

    printf(&amp;quot;\n&amp;quot;);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;코드-데이터-갱신&#34;&gt;코드 (데이터 갱신)&lt;/h3&gt;

&lt;p&gt;각 노드들에 인덱스를 매겨보면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-28-segment-tree-08.png&#34; alt=&#34;SegmentTree&#34; /&gt;&lt;/p&gt;

&lt;p&gt;와 같이 인덱스를 붙일 수 있습니다.
부모 노드와 자식 노드간의 관계는 아래 그림과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;{{ site.baseurl }}/assets/2016-03-28-segment-tree-09.png&#34; alt=&#34;SegmentTree&#34; /&gt;&lt;/p&gt;

&lt;p&gt;즉, 데이터 갱신은 다음과 같은 코드를 통해서 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void update(int pos, int value) {
    pos = pos + (N -1);
    segment_tree[pos] = value;

    while (true) {
        pos = pos / 2;
        if (pos == 0) break;
        segment_tree[pos] = 
            getMin(segment_tree[2 * pos], segment_tree[2 * pos + 1]);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;코드-데이터-조회&#34;&gt;코드 (데이터 조회)&lt;/h3&gt;

&lt;p&gt;데이터 조회 부분이 좀 복잡한데,
다음과 같은 재귀 함수를 이용해서 조회를 할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// left, right : 구하고자 하는 값의 범위
// segment_left, segment_right : 현재 Segment의 구간
// node_id : 현재 node의 index
int query(int left, int right, int segment_left, 
    int segment_right, int node_id) {
    // 전혀 관련이 없으면 INFINITE 리턴
    if ((segment_right &amp;lt; left) || (segment_left &amp;gt; right)) 
        return INFINITE;
    
    // 만약 현재 구간이 구하고자 하는 값의 범위 안에 있으면 SegmentTree값 리턴
    if ((segment_left &amp;gt;= left) &amp;amp;&amp;amp; (segment_right &amp;lt;= right)) 
        return segment_tree[node_id];

    // 현재 Segment의 중간점
    int mid = (segment_left + segment_right) / 2;

    int left_value = query(left, right, 
        segment_left, mid, 2 * node_id);
    int right_value = query(left, right, 
        mid + 1, segment_right, 2 * node_id + 1);

    return getMin(left_value, right_value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;코드-전체-소스-코드&#34;&gt;코드 (전체 소스 코드)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

static const int MAX_TREE_SIZE = 100000;
static const int INFINITE = 9999999;
int data[] = { 0, 6, 3, 7, 5, 2, 4, 8, 1, };
int N = 8;
int segment_tree[2 * MAX_TREE_SIZE];

int getMin(int a, int b) {
    if (a &amp;lt;= b) return a;
    return b;
}

void initialize() {
    int size = 2 * N - 1;
    for (int i = 1; i &amp;lt;= size; i++) {
        segment_tree[i] = INFINITE;
    }
}

void debug() {
    int size = 2 * N - 1;
    int pow = 2;
    for (int i = 1; i &amp;lt;= size; i++) {
        printf(&amp;quot;%d &amp;quot;, segment_tree[i]);
        if (i == (pow - 1)) {
            printf(&amp;quot;\n&amp;quot;);
            pow = pow * 2;
        }
    }

    printf(&amp;quot;\n&amp;quot;);
}

void update(int pos, int value) {
    pos = pos + (N -1);
    segment_tree[pos] = value;

    while (true) {
        pos = pos / 2;
        if (pos == 0) break;
        segment_tree[pos] = 
            getMin(segment_tree[2 * pos], segment_tree[2 * pos + 1]);
    }
}

// left, right : 구하고자 하는 값의 범위
// segment_left, segment_right : 현재 Segment의 구간
// node_id : 현재 node의 index
int query(int left, int right, int segment_left, 
    int segment_right, int node_id) {
    // 전혀 관련이 없으면 INFINITE 리턴
    if ((segment_right &amp;lt; left) || (segment_left &amp;gt; right)) 
        return INFINITE;
    
    // 만약 현재 구간이 구하고자 하는 값의 범위 안에 있으면 SegmentTree값 리턴
    if ((segment_left &amp;gt;= left) &amp;amp;&amp;amp; (segment_right &amp;lt;= right)) 
        return segment_tree[node_id];

    // 현재 Segment의 중간점
    int mid = (segment_left + segment_right) / 2;

    int left_value = query(left, right, 
        segment_left, mid, 2 * node_id);
    int right_value = query(left, right, 
        mid + 1, segment_right, 2 * node_id + 1);

    return getMin(left_value, right_value);
}

int main(int argc, char** argv) {
    initialize();

    for (int i = 1; i &amp;lt;= N; i++) {
        update(i, data[i]);
    }

    // Segment Tree 출력
    debug();

    // 최소값을 구하고자 하는 구간 입력
    int left = 2;
    int right = 8;
    int value = query(left, right, 1, N, 1);
    printf(&amp;quot;Minimum between %d and %d : %d\n&amp;quot;, 
        left, right, value);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
